//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import { Danger } from "../entities/Danger"
import { DangerCategory } from "../entities/DangerCategory"
import { DangerCategoryItemResponseModel } from "../entities/response/DangerCategoryItemResponseModel"
import { DangerCategoryListItemResponseModel } from "../entities/response/DangerCategoryListItemResponseModel"
import { DangerCategoryRequest } from "../entities/request/DangerCategoryRequest"
import { DangerItemResponseModel } from "../entities/response/DangerItemResponseModel"
import { DangerListItemResponseModel } from "../entities/response/DangerListItemResponseModel"
import { DangerMessage } from "../entities/DangerMessage"
import { DangerMessageItemResponseModel } from "../entities/response/DangerMessageItemResponseModel"
import { DangerMessageListItemResponseModel } from "../entities/response/DangerMessageListItemResponseModel"
import { DangerMessageRequest } from "../entities/request/DangerMessageRequest"
import { DangerModel } from "../entities/DangerModel"
import { DangerRequest } from "../entities/request/DangerRequest"
import { DangerRequestItemResponseModel } from "../entities/response/DangerRequestItemResponseModel"
import { DangerRequestListItemResponseModel } from "../entities/response/DangerRequestListItemResponseModel"
import { DangerRequestModel } from "../entities/request/DangerRequestModel"
import { ExpertRequest } from "../entities/ExpertRequest"
import { ExpertRequestItemResponseModel } from "../entities/response/ExpertRequestItemResponseModel"
import { ExpertRequestListItemResponseModel } from "../entities/response/ExpertRequestListItemResponseModel"
import { ExpertRequestModel } from "../entities/request/ExpertRequestModel"
import { LoginRequest } from "../entities/request/LoginRequest"
import { Notification } from "../entities/Notification"
import { NotificationItemResponseModel } from "../entities/response/NotificationItemResponseModel"
import { NotificationListItemResponseModel } from "../entities/response/NotificationListItemResponseModel"
import { NotificationRequest } from "../entities/request/NotificationRequest"
import { ProblemDetails } from "../entities/ProblemDetails"
import { RegisterRequest } from "../entities/request/RegisterRequest"
import { Route } from "../entities/Route"
import { RouteItemResponseModel } from "../entities/response/RouteItemResponseModel"
import { RouteListItemResponseModel } from "../entities/response/RouteListItemResponseModel"
import { RouteRequest } from "../entities/request/RouteRequest"
import { UpdateUserRequest } from "../entities/request/UpdateUserRequest"
import { UserItemResponseModel } from "../entities/response/UserItemResponseModel"
import { UserListItemResponseModel } from "../entities/response/UserListItemResponseModel"
import { UserResponseItemResponseModel } from "../entities/response/UserResponseItemResponseModel"
import { throwException } from "../error/throwException"

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming



export class DangerService {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any)
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }

  /**
   * Gets the entity with the specified ID.
   * @param id The ID of the entity to get.
   * @return Success
   */
  dangerGET(id: string): Promise<DangerItemResponseModel> {
    let url_ = this.baseUrl + "/api/Danger/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDangerGET(_response)
    })
  }

  protected processDangerGET(response: Response): Promise<DangerItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerItemResponseModel>(null as any)
  }

  /**
   * Updates an existing entity.
   * @param body (optional) The updated entity.
   * @return Success
   */
  dangerPUT(id: string, body: Danger | undefined): Promise<DangerItemResponseModel> {
    let url_ = this.baseUrl + "/api/Danger/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDangerPUT(_response)
    })
  }

  protected processDangerPUT(response: Response): Promise<DangerItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerItemResponseModel>(null as any)
  }

  /**
   * Deletes an entity with the specified ID.
   * @param id The ID of the entity to delete.
   * @return Success
   */
  dangerDELETE(id: string): Promise<DangerItemResponseModel> {
    let url_ = this.baseUrl + "/api/Danger/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "DELETE",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDangerDELETE(_response)
    })
  }

  protected processDangerDELETE(response: Response): Promise<DangerItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerItemResponseModel>(null as any)
  }

  /**
   * Gets all entities.
   * @return Success
   */
  dangerGET2(): Promise<DangerListItemResponseModel> {
    let url_ = this.baseUrl + "/api/Danger"
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDangerGET2(_response)
    })
  }

  protected processDangerGET2(response: Response): Promise<DangerListItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerListItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerListItemResponseModel>(null as any)
  }

  /**
   * Creates a new entity.
   * @param body (optional) The request model for the new entity.
   * @return Success
   */
  dangerPOST(body: DangerModel | undefined): Promise<DangerItemResponseModel> {
    let url_ = this.baseUrl + "/api/Danger"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDangerPOST(_response)
    })
  }

  protected processDangerPOST(response: Response): Promise<DangerItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null
        result201 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerItemResponseModel)
        return result201
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerItemResponseModel>(null as any)
  }
}

export class DangerCategoryService {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any)
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }

  /**
   * @param body (optional)
   * @return Success
   */
  dangerCategoryPUT(
    id: string,
    body: DangerCategory | undefined
  ): Promise<DangerCategoryItemResponseModel> {
    let url_ = this.baseUrl + "/api/DangerCategory/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDangerCategoryPUT(_response)
    })
  }

  protected processDangerCategoryPUT(response: Response): Promise<DangerCategoryItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerCategoryItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerCategoryItemResponseModel>(null as any)
  }

  /**
   * @return Success
   */
  dangerCategoryDELETE(id: string): Promise<DangerCategoryItemResponseModel> {
    let url_ = this.baseUrl + "/api/DangerCategory/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "DELETE",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDangerCategoryDELETE(_response)
    })
  }

  protected processDangerCategoryDELETE(
    response: Response
  ): Promise<DangerCategoryItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerCategoryItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerCategoryItemResponseModel>(null as any)
  }

  /**
   * Gets the entity with the specified ID.
   * @param id The ID of the entity to get.
   * @return Success
   */
  dangerCategoryGET(id: string): Promise<DangerCategoryItemResponseModel> {
    let url_ = this.baseUrl + "/api/DangerCategory/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDangerCategoryGET(_response)
    })
  }

  protected processDangerCategoryGET(response: Response): Promise<DangerCategoryItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerCategoryItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerCategoryItemResponseModel>(null as any)
  }

  /**
   * Gets all entities.
   * @return Success
   */
  dangerCategoryGET2(): Promise<DangerCategoryListItemResponseModel> {
    let url_ = this.baseUrl + "/api/DangerCategory"
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDangerCategoryGET2(_response)
    })
  }

  protected processDangerCategoryGET2(
    response: Response
  ): Promise<DangerCategoryListItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as DangerCategoryListItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerCategoryListItemResponseModel>(null as any)
  }

  /**
   * Creates a new entity.
   * @param body (optional) The request model for the new entity.
   * @return Success
   */
  dangerCategoryPOST(
    body: DangerCategoryRequest | undefined
  ): Promise<DangerCategoryItemResponseModel> {
    let url_ = this.baseUrl + "/api/DangerCategory"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDangerCategoryPOST(_response)
    })
  }

  protected processDangerCategoryPOST(
    response: Response
  ): Promise<DangerCategoryItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerCategoryItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null
        result201 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerCategoryItemResponseModel)
        return result201
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerCategoryItemResponseModel>(null as any)
  }
}

export class DangerMessageService {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any)
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }

  /**
   * @return Success
   */
  messageGET(dangerId: string): Promise<DangerMessageListItemResponseModel> {
    let url_ = this.baseUrl + "/api/Danger/{dangerId}/Message"
    if (dangerId === undefined || dangerId === null)
      throw new Error("The parameter 'dangerId' must be defined.")
    url_ = url_.replace("{dangerId}", encodeURIComponent("" + dangerId))
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMessageGET(_response)
    })
  }

  protected processMessageGET(response: Response): Promise<DangerMessageListItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as DangerMessageListItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerMessageListItemResponseModel>(null as any)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  messagePOST(
    dangerId: string,
    body: DangerMessageRequest | undefined
  ): Promise<DangerMessageItemResponseModel> {
    let url_ = this.baseUrl + "/api/Danger/{dangerId}/Message"
    if (dangerId === undefined || dangerId === null)
      throw new Error("The parameter 'dangerId' must be defined.")
    url_ = url_.replace("{dangerId}", encodeURIComponent("" + dangerId))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMessagePOST(_response)
    })
  }

  protected processMessagePOST(response: Response): Promise<DangerMessageItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerMessageItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerMessageItemResponseModel>(null as any)
  }

  /**
   * @param body (optional)
   * @return Success
   */
  messagePUT(
    dangerId: string,
    body: DangerMessage | undefined
  ): Promise<DangerMessageItemResponseModel> {
    let url_ = this.baseUrl + "/api/Danger/{dangerId}/Message"
    if (dangerId === undefined || dangerId === null)
      throw new Error("The parameter 'dangerId' must be defined.")
    url_ = url_.replace("{dangerId}", encodeURIComponent("" + dangerId))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMessagePUT(_response)
    })
  }

  protected processMessagePUT(response: Response): Promise<DangerMessageItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerMessageItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerMessageItemResponseModel>(null as any)
  }

  /**
   * @param id (optional)
   * @return Success
   */
  messageDELETE(id: string | undefined, dangerId: string): Promise<DangerMessageItemResponseModel> {
    let url_ = this.baseUrl + "/api/Danger/{dangerId}/Message?"
    if (dangerId === undefined || dangerId === null)
      throw new Error("The parameter 'dangerId' must be defined.")
    url_ = url_.replace("{dangerId}", encodeURIComponent("" + dangerId))
    if (id === null) throw new Error("The parameter 'id' cannot be null.")
    else if (id !== undefined) url_ += "id=" + encodeURIComponent("" + id) + "&"
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "DELETE",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMessageDELETE(_response)
    })
  }

  protected processMessageDELETE(response: Response): Promise<DangerMessageItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerMessageItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerMessageItemResponseModel>(null as any)
  }

  /**
   * @return Success
   */
  messageGET2(id: string, dangerId: string): Promise<DangerMessageItemResponseModel> {
    let url_ = this.baseUrl + "/api/Danger/{dangerId}/Message/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    if (dangerId === undefined || dangerId === null)
      throw new Error("The parameter 'dangerId' must be defined.")
    url_ = url_.replace("{dangerId}", encodeURIComponent("" + dangerId))
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMessageGET2(_response)
    })
  }

  protected processMessageGET2(response: Response): Promise<DangerMessageItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerMessageItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerMessageItemResponseModel>(null as any)
  }
}

export class DangerRequestService {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any)
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }

  /**
   * Gets the entity with the specified ID.
   * @param id The ID of the entity to get.
   * @return Success
   */
  requestGET(id: string): Promise<DangerRequestItemResponseModel> {
    let url_ = this.baseUrl + "/api/Danger/Request/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRequestGET(_response)
    })
  }

  protected processRequestGET(response: Response): Promise<DangerRequestItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerRequestItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerRequestItemResponseModel>(null as any)
  }

  /**
   * Updates an existing entity.
   * @param body (optional) The updated entity.
   * @return Success
   */
  requestPUT(id: string, body: DangerRequest | undefined): Promise<DangerRequestItemResponseModel> {
    let url_ = this.baseUrl + "/api/Danger/Request/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRequestPUT(_response)
    })
  }

  protected processRequestPUT(response: Response): Promise<DangerRequestItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerRequestItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerRequestItemResponseModel>(null as any)
  }

  /**
   * Deletes an entity with the specified ID.
   * @param id The ID of the entity to delete.
   * @return Success
   */
  requestDELETE(id: string): Promise<DangerRequestItemResponseModel> {
    let url_ = this.baseUrl + "/api/Danger/Request/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "DELETE",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRequestDELETE(_response)
    })
  }

  protected processRequestDELETE(response: Response): Promise<DangerRequestItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerRequestItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerRequestItemResponseModel>(null as any)
  }

  /**
   * Gets all entities.
   * @return Success
   */
  requestGET2(): Promise<DangerRequestListItemResponseModel> {
    let url_ = this.baseUrl + "/api/Danger/Request"
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRequestGET2(_response)
    })
  }

  protected processRequestGET2(response: Response): Promise<DangerRequestListItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as DangerRequestListItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerRequestListItemResponseModel>(null as any)
  }

  /**
   * Creates a new entity.
   * @param body (optional) The request model for the new entity.
   * @return Success
   */
  requestPOST(body: DangerRequestModel | undefined): Promise<DangerRequestItemResponseModel> {
    let url_ = this.baseUrl + "/api/Danger/Request"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRequestPOST(_response)
    })
  }

  protected processRequestPOST(response: Response): Promise<DangerRequestItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerRequestItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null
        result201 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as DangerRequestItemResponseModel)
        return result201
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<DangerRequestItemResponseModel>(null as any)
  }
}

export class ExpertRequestService {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any)
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }

  /**
   * Gets the entity with the specified ID.
   * @param id The ID of the entity to get.
   * @return Success
   */
  expertRequestGET(id: string): Promise<ExpertRequestItemResponseModel> {
    let url_ = this.baseUrl + "/api/ExpertRequest/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processExpertRequestGET(_response)
    })
  }

  protected processExpertRequestGET(response: Response): Promise<ExpertRequestItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ExpertRequestItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<ExpertRequestItemResponseModel>(null as any)
  }

  /**
   * Updates an existing entity.
   * @param body (optional) The updated entity.
   * @return Success
   */
  expertRequestPUT(
    id: string,
    body: ExpertRequest | undefined
  ): Promise<ExpertRequestItemResponseModel> {
    let url_ = this.baseUrl + "/api/ExpertRequest/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processExpertRequestPUT(_response)
    })
  }

  protected processExpertRequestPUT(response: Response): Promise<ExpertRequestItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ExpertRequestItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<ExpertRequestItemResponseModel>(null as any)
  }

  /**
   * Deletes an entity with the specified ID.
   * @param id The ID of the entity to delete.
   * @return Success
   */
  expertRequestDELETE(id: string): Promise<ExpertRequestItemResponseModel> {
    let url_ = this.baseUrl + "/api/ExpertRequest/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "DELETE",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processExpertRequestDELETE(_response)
    })
  }

  protected processExpertRequestDELETE(
    response: Response
  ): Promise<ExpertRequestItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ExpertRequestItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<ExpertRequestItemResponseModel>(null as any)
  }

  /**
   * Gets all entities.
   * @return Success
   */
  expertRequestGET2(): Promise<ExpertRequestListItemResponseModel> {
    let url_ = this.baseUrl + "/api/ExpertRequest"
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processExpertRequestGET2(_response)
    })
  }

  protected processExpertRequestGET2(
    response: Response
  ): Promise<ExpertRequestListItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ExpertRequestListItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<ExpertRequestListItemResponseModel>(null as any)
  }

  /**
   * Creates a new entity.
   * @param body (optional) The request model for the new entity.
   * @return Success
   */
  expertRequestPOST(body: ExpertRequestModel | undefined): Promise<ExpertRequestItemResponseModel> {
    let url_ = this.baseUrl + "/api/ExpertRequest"
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processExpertRequestPOST(_response)
    })
  }

  protected processExpertRequestPOST(response: Response): Promise<ExpertRequestItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ExpertRequestItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null
        result201 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ExpertRequestItemResponseModel)
        return result201
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<ExpertRequestItemResponseModel>(null as any)
  }
}



// export class RouteService {
//   private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
//   private baseUrl: string
//   protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

//   constructor(
//     baseUrl?: string,
//     http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
//   ) {
//     this.http = http ? http : (window as any)
//     this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
//   }

//   /**
//    * Gets the entity with the specified ID.
//    * @param id The ID of the entity to get.
//    * @return Success
//    */
//   routeGET(id: string): Promise<RouteItemResponseModel> {
//     let url_ = this.baseUrl + "/api/Route/{id}"
//     if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
//     url_ = url_.replace("{id}", encodeURIComponent("" + id))
//     url_ = url_.replace(/[?&]$/, "")

//     let options_: RequestInit = {
//       method: "GET",
//       headers: {
//         Accept: "text/plain",
//       },
//     }

//     return this.http.fetch(url_, options_).then((_response: Response) => {
//       return this.processRouteGET(_response)
//     })
//   }

//   protected processRouteGET(response: Response): Promise<RouteItemResponseModel> {
//     const status = response.status
//     let _headers: any = {}
//     if (response.headers && response.headers.forEach) {
//       response.headers.forEach((v: any, k: any) => (_headers[k] = v))
//     }
//     if (status === 200) {
//       return response.text().then((_responseText) => {
//         let result200: any = null
//         result200 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as RouteItemResponseModel)
//         return result200
//       })
//     } else if (status === 400) {
//       return response.text().then((_responseText) => {
//         let result400: any = null
//         result400 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
//         return throwException("Bad Request", status, _responseText, _headers, result400)
//       })
//     } else if (status === 401) {
//       return response.text().then((_responseText) => {
//         let result401: any = null
//         result401 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
//         return throwException("Unauthorized", status, _responseText, _headers, result401)
//       })
//     } else if (status === 404) {
//       return response.text().then((_responseText) => {
//         let result404: any = null
//         result404 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
//         return throwException("Not Found", status, _responseText, _headers, result404)
//       })
//     } else if (status !== 200 && status !== 204) {
//       return response.text().then((_responseText) => {
//         return throwException(
//           "An unexpected server error occurred.",
//           status,
//           _responseText,
//           _headers
//         )
//       })
//     }
//     return Promise.resolve<RouteItemResponseModel>(null as any)
//   }

//   /**
//    * Updates an existing entity.
//    * @param body (optional) The updated entity.
//    * @return Success
//    */
//   routePUT(id: string, body: Route | undefined): Promise<RouteItemResponseModel> {
//     let url_ = this.baseUrl + "/api/Route/{id}"
//     if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
//     url_ = url_.replace("{id}", encodeURIComponent("" + id))
//     url_ = url_.replace(/[?&]$/, "")

//     const content_ = JSON.stringify(body)

//     let options_: RequestInit = {
//       body: content_,
//       method: "PUT",
//       headers: {
//         "Content-Type": "application/json-patch+json",
//         Accept: "text/plain",
//       },
//     }

//     return this.http.fetch(url_, options_).then((_response: Response) => {
//       return this.processRoutePUT(_response)
//     })
//   }

//   protected processRoutePUT(response: Response): Promise<RouteItemResponseModel> {
//     const status = response.status
//     let _headers: any = {}
//     if (response.headers && response.headers.forEach) {
//       response.headers.forEach((v: any, k: any) => (_headers[k] = v))
//     }
//     if (status === 200) {
//       return response.text().then((_responseText) => {
//         let result200: any = null
//         result200 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as RouteItemResponseModel)
//         return result200
//       })
//     } else if (status === 400) {
//       return response.text().then((_responseText) => {
//         let result400: any = null
//         result400 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
//         return throwException("Bad Request", status, _responseText, _headers, result400)
//       })
//     } else if (status === 401) {
//       return response.text().then((_responseText) => {
//         let result401: any = null
//         result401 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
//         return throwException("Unauthorized", status, _responseText, _headers, result401)
//       })
//     } else if (status === 404) {
//       return response.text().then((_responseText) => {
//         let result404: any = null
//         result404 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
//         return throwException("Not Found", status, _responseText, _headers, result404)
//       })
//     } else if (status !== 200 && status !== 204) {
//       return response.text().then((_responseText) => {
//         return throwException(
//           "An unexpected server error occurred.",
//           status,
//           _responseText,
//           _headers
//         )
//       })
//     }
//     return Promise.resolve<RouteItemResponseModel>(null as any)
//   }

//   /**
//    * Deletes an entity with the specified ID.
//    * @param id The ID of the entity to delete.
//    * @return Success
//    */
//   routeDELETE(id: string): Promise<RouteItemResponseModel> {
//     let url_ = this.baseUrl + "/api/Route/{id}"
//     if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
//     url_ = url_.replace("{id}", encodeURIComponent("" + id))
//     url_ = url_.replace(/[?&]$/, "")

//     let options_: RequestInit = {
//       method: "DELETE",
//       headers: {
//         Accept: "text/plain",
//       },
//     }

//     return this.http.fetch(url_, options_).then((_response: Response) => {
//       return this.processRouteDELETE(_response)
//     })
//   }

//   protected processRouteDELETE(response: Response): Promise<RouteItemResponseModel> {
//     const status = response.status
//     let _headers: any = {}
//     if (response.headers && response.headers.forEach) {
//       response.headers.forEach((v: any, k: any) => (_headers[k] = v))
//     }
//     if (status === 200) {
//       return response.text().then((_responseText) => {
//         let result200: any = null
//         result200 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as RouteItemResponseModel)
//         return result200
//       })
//     } else if (status === 400) {
//       return response.text().then((_responseText) => {
//         let result400: any = null
//         result400 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
//         return throwException("Bad Request", status, _responseText, _headers, result400)
//       })
//     } else if (status === 401) {
//       return response.text().then((_responseText) => {
//         let result401: any = null
//         result401 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
//         return throwException("Unauthorized", status, _responseText, _headers, result401)
//       })
//     } else if (status === 404) {
//       return response.text().then((_responseText) => {
//         let result404: any = null
//         result404 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
//         return throwException("Not Found", status, _responseText, _headers, result404)
//       })
//     } else if (status !== 200 && status !== 204) {
//       return response.text().then((_responseText) => {
//         return throwException(
//           "An unexpected server error occurred.",
//           status,
//           _responseText,
//           _headers
//         )
//       })
//     }
//     return Promise.resolve<RouteItemResponseModel>(null as any)
//   }

//   /**
//    * Gets all entities.
//    * @return Success
//    */
//   routeGET2(): Promise<RouteListItemResponseModel> {
//     let url_ = this.baseUrl + "/api/Route"
//     url_ = url_.replace(/[?&]$/, "")

//     let options_: RequestInit = {
//       method: "GET",
//       headers: {
//         Accept: "text/plain",
//       },
//     }

//     return this.http.fetch(url_, options_).then((_response: Response) => {
//       return this.processRouteGET2(_response)
//     })
//   }

//   protected processRouteGET2(response: Response): Promise<RouteListItemResponseModel> {
//     const status = response.status
//     let _headers: any = {}
//     if (response.headers && response.headers.forEach) {
//       response.headers.forEach((v: any, k: any) => (_headers[k] = v))
//     }
//     if (status === 200) {
//       return response.text().then((_responseText) => {
//         let result200: any = null
//         result200 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as RouteListItemResponseModel)
//         return result200
//       })
//     } else if (status === 400) {
//       return response.text().then((_responseText) => {
//         let result400: any = null
//         result400 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
//         return throwException("Bad Request", status, _responseText, _headers, result400)
//       })
//     } else if (status === 401) {
//       return response.text().then((_responseText) => {
//         let result401: any = null
//         result401 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
//         return throwException("Unauthorized", status, _responseText, _headers, result401)
//       })
//     } else if (status === 404) {
//       return response.text().then((_responseText) => {
//         let result404: any = null
//         result404 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
//         return throwException("Not Found", status, _responseText, _headers, result404)
//       })
//     } else if (status !== 200 && status !== 204) {
//       return response.text().then((_responseText) => {
//         return throwException(
//           "An unexpected server error occurred.",
//           status,
//           _responseText,
//           _headers
//         )
//       })
//     }
//     return Promise.resolve<RouteListItemResponseModel>(null as any)
//   }

//   /**
//    * Creates a new entity.
//    * @param body (optional) The request model for the new entity.
//    * @return Success
//    */
//   routePOST(body: RouteRequest | undefined): Promise<RouteItemResponseModel> {
//     let url_ = this.baseUrl + "/api/Route"
//     url_ = url_.replace(/[?&]$/, "")

//     const content_ = JSON.stringify(body)

//     let options_: RequestInit = {
//       body: content_,
//       method: "POST",
//       headers: {
//         "Content-Type": "application/json-patch+json",
//         Accept: "text/plain",
//       },
//     }

//     return this.http.fetch(url_, options_).then((_response: Response) => {
//       return this.processRoutePOST(_response)
//     })
//   }

//   protected processRoutePOST(response: Response): Promise<RouteItemResponseModel> {
//     const status = response.status
//     let _headers: any = {}
//     if (response.headers && response.headers.forEach) {
//       response.headers.forEach((v: any, k: any) => (_headers[k] = v))
//     }
//     if (status === 200) {
//       return response.text().then((_responseText) => {
//         let result200: any = null
//         result200 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as RouteItemResponseModel)
//         return result200
//       })
//     } else if (status === 400) {
//       return response.text().then((_responseText) => {
//         let result400: any = null
//         result400 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
//         return throwException("Bad Request", status, _responseText, _headers, result400)
//       })
//     } else if (status === 401) {
//       return response.text().then((_responseText) => {
//         let result401: any = null
//         result401 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
//         return throwException("Unauthorized", status, _responseText, _headers, result401)
//       })
//     } else if (status === 404) {
//       return response.text().then((_responseText) => {
//         let result404: any = null
//         result404 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
//         return throwException("Not Found", status, _responseText, _headers, result404)
//       })
//     } else if (status === 201) {
//       return response.text().then((_responseText) => {
//         let result201: any = null
//         result201 =
//           _responseText === ""
//             ? null
//             : (JSON.parse(_responseText, this.jsonParseReviver) as RouteItemResponseModel)
//         return result201
//       })
//     } else if (status !== 200 && status !== 204) {
//       return response.text().then((_responseText) => {
//         return throwException(
//           "An unexpected server error occurred.",
//           status,
//           _responseText,
//           _headers
//         )
//       })
//     }
//     return Promise.resolve<RouteItemResponseModel>(null as any)
//   }
// }

export class UserService {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  private baseUrl: string
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any)
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : ""
  }

  /**
   * Endpoint to update a user.
   * @param id Id of the User
   * @param body (optional) UpdateBasicUserRequest that contains the properties to be updated
   * @return Success
   */
  userPUT(id: string, body: UpdateUserRequest | undefined): Promise<UserItemResponseModel> {
    let url_ = this.baseUrl + "/api/User/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserPUT(_response)
    })
  }

  protected processUserPUT(response: Response): Promise<UserItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as UserItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<UserItemResponseModel>(null as any)
  }

  /**
   * Gets the entity with the specified ID.
   * @param id The ID of the entity to get.
   * @return Success
   */
  userGET(id: string): Promise<UserItemResponseModel> {
    let url_ = this.baseUrl + "/api/User/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserGET(_response)
    })
  }

  protected processUserGET(response: Response): Promise<UserItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as UserItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<UserItemResponseModel>(null as any)
  }

  /**
   * Deletes an entity with the specified ID.
   * @param id The ID of the entity to delete.
   * @return Success
   */
  userDELETE(id: string): Promise<UserItemResponseModel> {
    let url_ = this.baseUrl + "/api/User/{id}"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "DELETE",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserDELETE(_response)
    })
  }

  protected processUserDELETE(response: Response): Promise<UserItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as UserItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<UserItemResponseModel>(null as any)
  }

  /**
   * Endpoint to ban a user.
   * @param id Id of the User which should be banned
   * @param body (optional) Sets banned to true or false (default: true)
   * @return Success
   */
  ban(id: string, body: boolean | undefined): Promise<UserItemResponseModel> {
    let url_ = this.baseUrl + "/api/User/{id}/Ban"
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.")
    url_ = url_.replace("{id}", encodeURIComponent("" + id))
    url_ = url_.replace(/[?&]$/, "")

    const content_ = JSON.stringify(body)

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processBan(_response)
    })
  }

  protected processBan(response: Response): Promise<UserItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as UserItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<UserItemResponseModel>(null as any)
  }

  /**
   * Endpoint which gets all banned user.
   * @return Success
   */
  banned(): Promise<UserListItemResponseModel> {
    let url_ = this.baseUrl + "/api/User/Banned"
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processBanned(_response)
    })
  }

  protected processBanned(response: Response): Promise<UserListItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as UserListItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<UserListItemResponseModel>(null as any)
  }

  /**
   * Gets all entities.
   * @return Success
   */
  userGET2(): Promise<UserListItemResponseModel> {
    let url_ = this.baseUrl + "/api/User"
    url_ = url_.replace(/[?&]$/, "")

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "text/plain",
      },
    }

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserGET2(_response)
    })
  }

  protected processUserGET2(response: Response): Promise<UserListItemResponseModel> {
    const status = response.status
    let _headers: any = {}
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v))
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as UserListItemResponseModel)
        return result200
      })
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null
        result400 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Bad Request", status, _responseText, _headers, result400)
      })
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null
        result401 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Unauthorized", status, _responseText, _headers, result401)
      })
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null
        result404 =
          _responseText === ""
            ? null
            : (JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails)
        return throwException("Not Found", status, _responseText, _headers, result404)
      })
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        )
      })
    }
    return Promise.resolve<UserListItemResponseModel>(null as any)
  }
}
